## 解题 4 步骤

<!-- 题目，2，5，7三种硬币，要给老板27块钱，最少的硬币组合解 -->

1. 确定状态

   - 解动态规划 需要开一个数组，数组每个元素代表什么，类似数学题中 x,y,z 代表什么
   - 需要 2 个状态，
   - 最后一步
     - 最优 策略 一定是 a1,a2...ak
     - 一定有一枚 **最后的** 的硬币， ak
     - 除掉这枚硬币，前面的硬币面额 加起来是 27 - ak
   - 子问题

2. 转移方程

```js
f[x] = min{f[x-2], f[x-5], f[x-7]} + 1
```

3. 初始条件 和 边界情况

4. 计算顺序

## 题目如下

- 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回  -1。

你可以认为每种硬币的数量是无限的。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/gaM7Ch
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```ts
function coinChange(coins: number[], amount: number): number {
  const resultMap = new Map<number, number>();

  // 初始值
  resultMap.set(0, 0);

  for (let i = 1; i <= amount; i++) {
    const allCount: number[] = [];
    for (let j = 0; j < coins.length; j++) {
      const coinsVal = coins[j];
      const changeCount =
        resultMap.get(i - coinsVal) ?? Number.MAX_SAFE_INTEGER;
      allCount.push(changeCount);
    }
    let minV = Math.min(...allCount);
    if (minV !== Number.MAX_SAFE_INTEGER) {
      resultMap.set(i, minV + 1);
    } else {
      resultMap.set(i, Number.MAX_SAFE_INTEGER);
    }
  }
  return resultMap.get(amount) !== Number.MAX_SAFE_INTEGER
    ? resultMap.get(amount)!
    : -1;
}

const c = [1, 2, 5];
const a = 11;
console.log(coinChange(c, a));
```

function lengthOfLIS(nums: number[]): number {
if (nums.length === 0) return 0;

    // 完成初始化，初始化
    const retMap: number[] = [Number.MIN_VALUE, nums[0]];
    for (let i = 1; i < nums.length; i++) {
        const currNum = nums[i];
        // 从左往右 依次比较，如果 currNum 小，则 替换当前元素，如果 currNum 大，则放在下一位
        retMap.forEach((retNum, retIndex, arr) => {
            if (currNum <= retNum) {
                // 等于 替换不替换 都行
                arr[retIndex] = currNum;
                return;
            }
            const isLast = retIndex === arr.length - 1;
            if (isLast) {
                // 最后一个元素 比 currNum 要小，则数组增加一位
                arr[arr.length] = currNum;
            }
        })
    }
    console.log(retMap)
    return retMap.length - 1;

};
