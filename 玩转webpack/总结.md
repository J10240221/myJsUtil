各种任务就是：比如解析 HTML，压缩 js，CSS，资源添加指纹等 grunp 和 gulp 都是 task runner，依次执行任务但是前者每个任务执行要都会生成文件 放在.temp 目录下，后者这是通过文件流 存放在内存中，上一个任务的流传给下一个任务使用，减少了磁盘 io 提高了速度

---

- npm run webpack 可以执行的原理

  - 本地模块安装，会在 node_modules/.bin 目录创建软连接，指向模块的 bin 目录，也就是 node_modules/webpack/package.json 中的 bin 字段的位置，也就是 webpack/bin/webpack.js
  - npm run xxx 就会新建一个 shell,把 node_modules/.bin 子目录加入到 PATH 环境变量中，然后执行结束后删除这个环境变量，因此我们还可以直接执行本地安装依赖自带的命令

- entry 单入口就是路径字符串，多入口则变为对象，{入口 1key: 路径，入口 2key: 路径}
- output 则不会有单入口多入口的差异，只不过 单入口可以指定明确的文件名，如 bundle.js，多入口则需要使用占位符，如 [name].js
- mode 有 production, development, none 三种模式，分别会有不同的优化，如 pro 会开启压缩，sideEffects 字段检查等；dev 会开启 某个文件出发 hmr 后打印输出等；none 则什么优化都不会做
- loader 处理资源的转换
- plugin 可以做 所有 loader 做不了的事情，并可以在全生命周期的任何阶段执行
- 其他杂项
  - watch 的原理
    - 轮询判断文件的最后编辑时间是否变化
      - 某个文件发生变化，并不会立马告诉监听者，而是先缓存起来，等 aggregateTimeout 后(默认 300ms)执行
      ```js
      module.export = {
        watch: true,
        watchOptions: {
          ignored: /node_modules/,
          aggregateTimeout: 300,
          poll: 1000, // 默认每秒向系统轮询1千次，文件是否改变
        },
      };
      ```
  - file-loader 和 url-loader 的区别
    - FL 主要做 2 件事，
      - a. 把引入图片资源的代码 替换为一个 js 代码,内容是一个路径；
        ```js
        function loader(content) {
          // 省略其他代码
          return `${esModule ? 'export default' : 'module.exports ='} ${publicPath};`;
        }
        ```
      - b. 把资源拷贝到指定的位置
        ```js
        this.emitFile(outputPath, content, null, assetInfo);
        ```
    - UL url-loader works like file-loader, but can return a DataURL if the file is smaller than a byte limit. 做的是把资源用 url 去编码；比如之前 h1.1 常规的配置，< 10kb 的采用 base64 编码，否则默认采用 FL 的方式

---
